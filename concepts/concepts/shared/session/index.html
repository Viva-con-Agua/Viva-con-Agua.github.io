<!DOCTYPE html><html lang="en-US"><head><title data-react-helmet="true"></title><link rel="preload" as="script" href="/bootstrap.a38652b5.js"/><link rel="preload" as="script" href="/templates/src/containers/Concept.28f11c11.js"/><link rel="preload" as="script" href="/main.371b4f07.js"/><link rel="preload" as="style" href="/styles.8277b960.css"/><link rel="stylesheet" href="/styles.8277b960.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, shrink-to-fit=no"/></head><body><div id="root"><div data-reactroot=""><nav><a class="brand active" aria-current="true" href="/"><img src="data:image/png;base64,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" alt="Viva con Agua logo"/><div><span class="bold">Pool²</span><span>Documentation</span></div></a><a class="text active" aria-current="true" href="/concepts">Concepts</a><a class="text" aria-current="false" href="/guides">Guides</a><a class="text" aria-current="false" href="/rest">REST Interfaces</a><a class="text" aria-current="false" href="/about">About</a><span>This documentation is still under construction...</span></nav><div class="content"><div><a class="active" aria-current="true" href="/concepts/">&lt;<!-- --> Back</a><br/><h3>Shared Session</h3><h1 id="shared-session">Shared Session</h1>
<p>The Pool² is a collaboration support tool. Thus, almost all microserives implementing functional requirements need to 
identify the user. A unique authentication for every microservice implies a lot of problems: There are more possible 
problem sources, maintenance becomes hard to apply and a user needs to enter his or her credentials every time the user 
switch between microservices. The latter is serious usability issue and can hinder adaption. Therefore, the Pool² 
implements an <a href="https://oauth.net/2/">OAuth 2</a> provider that can be used to share a users session between microservices.</p>
<p>The microservice <em>Drops</em> implements a secured session handling and an OAuth 2 provider that trusts all microservices that 
are deployed inside the VcA-infrastructure. Therefore, it implements an OAuth 2 handshake using grant type 
<a href="https://oauth.net/2/grant-types/authorization-code/">Authorization Code</a> that redirects to a OAuth client with an 
authorization code without asking the users permission. The OAuth client has to be part of the internal microservice 
network to receive an access token. Thus, the users data is kept save without asking for the users permission on each 
time the user switches between microservices.<br/>
<strong><em>Hint:</em></strong> Drops does not implement the original <a href="https://oauth.net/2/grant-types/authorization-code/">Authorization Code</a>
workflow. So, there is no way to receive an access token from without the internal microservice network.</p>
<p>Authentication of microservices becomes a critical security challenge for the Pool² architecture. <em>Drops</em> can trust a 
microservice if and only if the microservice is hosted by VcA. Undoubtedly, microservices can implement security issues, 
but since VcA is a socio-technical organization, we need to ensure clean implementation of microservices during a quality 
assurance process before deployment. For now, all microservices are deployed using a virtual network at the one server, 
so no external communication (using the internet or at least LAN) is needed (see <a href="guide/deployment">deployment</a>). 
Thus, authentication is implemented using a naive microservice id and secret combination. This combination is send only 
for requesting the access token.<br/>
<strong>To consider:</strong> Ensure that the authentication data of your microservice is secret for each deployment (test, staging, live)!
Additonally, do <strong>not</strong> save these data in any kind of client application, like javascript Web-Apps! These types of
application will be discussed later.</p>
<h2 id="oauth-2-handshake">OAuth 2 handshake</h2>
<p><em>Drops</em> allows the user to initiate a server session. A encrypted <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP cookie</a>
is used to store all information needed to identify the user on server side. Additionally, <em>Drops</em> implements an OAuth2
provider. Thus, another microservice is able to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections"><code>REDIRECT</code></a>
to <em>Drops</em> in order to request an authorization code.</p>
<ol>
<li>Request from <code>Client</code> to <code>Microservice</code></li>
<li><code>REDIRECT</code> from <code>Microservice</code> to <code>Drops</code></li>
<li><code>Drops</code> checks if the redirecting <code>Microservice</code> is trusted (the URL contains an identifier)</li>
<li><code>Drops</code> generates the <code>Authorization code</code></li>
<li><code>Drops</code> redirects back to the <code>Microservice</code> OAuth2 endpoint (given as parameter AND saved in <code>Drops</code> database)</li>
<li><code>Microservice</code> is able to initiate a direct REST-based communication to <code>Drops</code> and requests the <code>Access Token</code> without
redirect</li>
<li><code>Drops</code> responses with the users data</li>
<li><code>Microservice</code> can initiate its own user session</li>
</ol>
<h2 id="web-apps">Web Apps</h2>
<p>Some microservices will implement a Web-App architecture. Such applications are based on HTML, CSS and Javascript. Mostly,
there is also some backend implementing a RESTful API to save and synchronize data entered by users.</p>
<p>If the microservice credentials are saved on client devices, our concept of trusted OAuth2 handshake has serious security
issues since we are not able to prevent misuse of these credentials. Thus, the backend systems have to handle the trusted 
OAuth2 handshake. </p>
<p>The question remains of how to implement the user session for the frontend. Short answer: You won&#x27;t need 
a frontend session. The user session is needed for three purposes: (1) Control access, (2) use the user information 
for further handling, and (3) display the user.</p>
<p>First, you have to keep in mind, that your and your users data is protected by the backend. So, if a user tries to request
specific data using your RESTful API, your backend can grant or forbid access. Thus, if a user is entering spaces that 
are not allowed for this user, your backend won&#x27;t send data, but it can send a status <code>403 FORBIDDEN</code> and an optional 
message. That way your frontend can handle the access control.</p>
<p>Second, to handle the currently logged in user, your backend has to implement a special route that (1) is secured and (2)
return the <code>UUID</code> of the user. Thus, the frontend can use the user in forms and other interaction elements. If your system
has to display the user (case (3)), you should use <a href="concepts/ui/fragment/composition">widgets</a> for user display prepared 
by <em>Drops</em>.</p>
<p>In case your frontend is delivered by a special webserver with no connection to your backend system, you have to implement
the trusted OAuth2 handshake for the delivering webserver to receive the users <code>UUID</code>.</p>
<h2 id="oauth-message-broker">OAuth Message broker</h2>
<p>If the trusted OAuth2 handshake was successful, a users session can be established. An important requirement is to keep
the session synchronized. That means, updates of the exchanged user information have to be cascaded, and also the logout
event.</p>
<p>For this purpose, the Pool² infrastructure hosts a message broker system. <em>Drops</em> publishes these events:</p>
<pre><code>type: LOGOUT
body: UUID of user
</code></pre><pre><code>type: user.UPDATE
body: UUID of user
</code></pre><pre><code>type: user.CREATE
body: UUID of user
</code></pre><pre><code>type: user.DELETE
body: UUID of user
</code></pre><p>Your microservice can listen to these events for the purpose of synchronization. For further information about the message
broker see the <a href="guide/deployment">guide for deployment</a>.</p>
<p><strong>Author:</strong> <a href="https://cses.informatik.hu-berlin.de/members/johann.sell/">Johann Sell</a> -- 
<strong>Created:</strong> 2018-06-05 --
<strong>Updated:</strong> 2018-06-05</p></div></div></div></div><script type="text/javascript">window.__CSS_CHUNKS__ = {"main":"/styles.8277b960.css"}</script><script type="text/javascript">
                window.__routeInfo = {'path':'concepts/concepts/shared/session','templateID':3,'sharedPropsHashes':{},'localProps':null,'allProps':{'concept':{'title':'Shared Session','slug':'concepts/shared/session','contents':'<h1 id="shared-session">Shared Session</h1>\n<p>The Pool\xB2 is a collaboration support tool. Thus, almost all microserives implementing functional requirements need to \nidentify the user. A unique authentication for every microservice implies a lot of problems: There are more possible \nproblem sources, maintenance becomes hard to apply and a user needs to enter his or her credentials every time the user \nswitch between microservices. The latter is serious usability issue and can hinder adaption. Therefore, the Pool\xB2 \nimplements an <a href="https://oauth.net/2/">OAuth 2</a> provider that can be used to share a users session between microservices.</p>\n<p>The microservice <em>Drops</em> implements a secured session handling and an OAuth 2 provider that trusts all microservices that \nare deployed inside the VcA-infrastructure. Therefore, it implements an OAuth 2 handshake using grant type \n<a href="https://oauth.net/2/grant-types/authorization-code/">Authorization Code</a> that redirects to a OAuth client with an \nauthorization code without asking the users permission. The OAuth client has to be part of the internal microservice \nnetwork to receive an access token. Thus, the users data is kept save without asking for the users permission on each \ntime the user switches between microservices.<br />\n<strong><em>Hint:</em></strong> Drops does not implement the original <a href="https://oauth.net/2/grant-types/authorization-code/">Authorization Code</a>\nworkflow. So, there is no way to receive an access token from without the internal microservice network.</p>\n<p>Authentication of microservices becomes a critical security challenge for the Pool\xB2 architecture. <em>Drops</em> can trust a \nmicroservice if and only if the microservice is hosted by VcA. Undoubtedly, microservices can implement security issues, \nbut since VcA is a socio-technical organization, we need to ensure clean implementation of microservices during a quality \nassurance process before deployment. For now, all microservices are deployed using a virtual network at the one server, \nso no external communication (using the internet or at least LAN) is needed (see <a href="guide/deployment">deployment</a>). \nThus, authentication is implemented using a naive microservice id and secret combination. This combination is send only \nfor requesting the access token.<br />\n<strong>To consider:</strong> Ensure that the authentication data of your microservice is secret for each deployment (test, staging, live)!\nAdditonally, do <strong>not</strong> save these data in any kind of client application, like javascript Web-Apps! These types of\napplication will be discussed later.</p>\n<h2 id="oauth-2-handshake">OAuth 2 handshake</h2>\n<p><em>Drops</em> allows the user to initiate a server session. A encrypted <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP cookie</a>\nis used to store all information needed to identify the user on server side. Additionally, <em>Drops</em> implements an OAuth2\nprovider. Thus, another microservice is able to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections"><code>REDIRECT</code></a>\nto <em>Drops</em> in order to request an authorization code.</p>\n<ol>\n<li>Request from <code>Client</code> to <code>Microservice</code></li>\n<li><code>REDIRECT</code> from <code>Microservice</code> to <code>Drops</code></li>\n<li><code>Drops</code> checks if the redirecting <code>Microservice</code> is trusted (the URL contains an identifier)</li>\n<li><code>Drops</code> generates the <code>Authorization code</code></li>\n<li><code>Drops</code> redirects back to the <code>Microservice</code> OAuth2 endpoint (given as parameter AND saved in <code>Drops</code> database)</li>\n<li><code>Microservice</code> is able to initiate a direct REST-based communication to <code>Drops</code> and requests the <code>Access Token</code> without\nredirect</li>\n<li><code>Drops</code> responses with the users data</li>\n<li><code>Microservice</code> can initiate its own user session</li>\n</ol>\n<h2 id="web-apps">Web Apps</h2>\n<p>Some microservices will implement a Web-App architecture. Such applications are based on HTML, CSS and Javascript. Mostly,\nthere is also some backend implementing a RESTful API to save and synchronize data entered by users.</p>\n<p>If the microservice credentials are saved on client devices, our concept of trusted OAuth2 handshake has serious security\nissues since we are not able to prevent misuse of these credentials. Thus, the backend systems have to handle the trusted \nOAuth2 handshake. </p>\n<p>The question remains of how to implement the user session for the frontend. Short answer: You won&#39;t need \na frontend session. The user session is needed for three purposes: (1) Control access, (2) use the user information \nfor further handling, and (3) display the user.</p>\n<p>First, you have to keep in mind, that your and your users data is protected by the backend. So, if a user tries to request\nspecific data using your RESTful API, your backend can grant or forbid access. Thus, if a user is entering spaces that \nare not allowed for this user, your backend won&#39;t send data, but it can send a status <code>403 FORBIDDEN</code> and an optional \nmessage. That way your frontend can handle the access control.</p>\n<p>Second, to handle the currently logged in user, your backend has to implement a special route that (1) is secured and (2)\nreturn the <code>UUID</code> of the user. Thus, the frontend can use the user in forms and other interaction elements. If your system\nhas to display the user (case (3)), you should use <a href="concepts/ui/fragment/composition">widgets</a> for user display prepared \nby <em>Drops</em>.</p>\n<p>In case your frontend is delivered by a special webserver with no connection to your backend system, you have to implement\nthe trusted OAuth2 handshake for the delivering webserver to receive the users <code>UUID</code>.</p>\n<h2 id="oauth-message-broker">OAuth Message broker</h2>\n<p>If the trusted OAuth2 handshake was successful, a users session can be established. An important requirement is to keep\nthe session synchronized. That means, updates of the exchanged user information have to be cascaded, and also the logout\nevent.</p>\n<p>For this purpose, the Pool\xB2 infrastructure hosts a message broker system. <em>Drops</em> publishes these events:</p>\n<pre><code>type: LOGOUT\nbody: UUID of user\n</code></pre><pre><code>type: user.UPDATE\nbody: UUID of user\n</code></pre><pre><code>type: user.CREATE\nbody: UUID of user\n</code></pre><pre><code>type: user.DELETE\nbody: UUID of user\n</code></pre><p>Your microservice can listen to these events for the purpose of synchronization. For further information about the message\nbroker see the <a href="guide/deployment">guide for deployment</a>.</p>\n<p><strong>Author:</strong> <a href="https://cses.informatik.hu-berlin.de/members/johann.sell/">Johann Sell</a> -- \n<strong>Created:</strong> 2018-06-05 --\n<strong>Updated:</strong> 2018-06-05</p>\n'}},'siteData':{'title':'Pool\xB2 Documentation'}};</script><script defer="" type="text/javascript" src="/bootstrap.a38652b5.js"></script><script defer="" type="text/javascript" src="/templates/src/containers/Concept.28f11c11.js"></script><script defer="" type="text/javascript" src="/main.371b4f07.js"></script></body></html>