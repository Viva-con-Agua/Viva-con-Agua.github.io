{"path":"concepts","templateID":4,"sharedPropsHashes":{},"localProps":{"concepts":[{"title":"Epic Issue","slug":"concepts/epic/issue","contents":"<h1 id=\"epic-issue\">Epic Issue</h1>\n<p>An Epic Issue describes a complete feature for one or more microservices. Epic issues are marked with the tag <em>Epic Issue</em> and the label <code>[EPIC]</code> as part of the issue title. The Autor has to describe the feature and define a list of acceptance criteria. When a developer assigns to the epic issue, he/she has to define a list of concrete tasks in the first step. The task list describes the planned implementation. By comparing the acceptance criteria with the task list, it has to be possible to check, if all requirements are fulfilled. This step has to treat before the developer starts to implement the feature. A second comparison is one step of the code review as part of the pull request.</p>\n<p>For a better overview, it will be useful to document the task list in the epic issue description. </p>\n<p>You can use this snippet (replace <code>[issue_number]</code> and <code>[issue_title]</code>): </p>\n<pre><code>## Task List\n* #[issue_number] - [issue_title]\n</code></pre>"},{"title":"Shared Session","slug":"concepts/shared/session","contents":"<h1 id=\"shared-session\">Shared Session</h1>\n<p>The Pool² is a collaboration support tool. Thus, almost all microserives implementing functional requirements need to \nidentify the user. A unique authentication for every microservice implies a lot of problems: There are more possible \nproblem sources, maintenance becomes hard to apply and a user needs to enter his or her credentials every time the user \nswitch between microservices. The latter is serious usability issue and can hinder adaption. Therefore, the Pool² \nimplements an <a href=\"https://oauth.net/2/\">OAuth 2</a> provider that can be used to share a users session between microservices.</p>\n<p>The microservice <em>Drops</em> implements a secured session handling and an OAuth 2 provider that trusts all microservices that \nare deployed inside the VcA-infrastructure. Therefore, it implements an OAuth 2 handshake using grant type \n<a href=\"https://oauth.net/2/grant-types/authorization-code/\">Authorization Code</a> that redirects to a OAuth client with an \nauthorization code without asking the users permission. The OAuth client has to be part of the internal microservice \nnetwork to receive an access token. Thus, the users data is kept save without asking for the users permission on each \ntime the user switches between microservices.<br />\n<strong><em>Hint:</em></strong> Drops does not implement the original <a href=\"https://oauth.net/2/grant-types/authorization-code/\">Authorization Code</a>\nworkflow. So, there is no way to receive an access token from without the internal microservice network.</p>\n<p>Authentication of microservices becomes a critical security challenge for the Pool² architecture. <em>Drops</em> can trust a \nmicroservice if and only if the microservice is hosted by VcA. Undoubtedly, microservices can implement security issues, \nbut since VcA is a socio-technical organization, we need to ensure clean implementation of microservices during a quality \nassurance process before deployment. For now, all microservices are deployed using a virtual network at the one server, \nso no external communication (using the internet or at least LAN) is needed (see <a href=\"guide/deployment\">deployment</a>). \nThus, authentication is implemented using a naive microservice id and secret combination. This combination is send only \nfor requesting the access token.<br />\n<strong>To consider:</strong> Ensure that the authentication data of your microservice is secret for each deployment (test, staging, live)!\nAdditonally, do <strong>not</strong> save these data in any kind of client application, like javascript Web-Apps! These types of\napplication will be discussed later.</p>\n<h2 id=\"oauth-2-handshake\">OAuth 2 handshake</h2>\n<p><em>Drops</em> allows the user to initiate a server session. A encrypted <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\">HTTP cookie</a>\nis used to store all information needed to identify the user on server side. Additionally, <em>Drops</em> implements an OAuth2\nprovider. Thus, another microservice is able to <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections\"><code>REDIRECT</code></a>\nto <em>Drops</em> in order to request an authorization code.</p>\n<ol>\n<li>Request from <code>Client</code> to <code>Microservice</code></li>\n<li><code>REDIRECT</code> from <code>Microservice</code> to <code>Drops</code></li>\n<li><code>Drops</code> checks if the redirecting <code>Microservice</code> is trusted (the URL contains an identifier)</li>\n<li><code>Drops</code> generates the <code>Authorization code</code></li>\n<li><code>Drops</code> redirects back to the <code>Microservice</code> OAuth2 endpoint (given as parameter AND saved in <code>Drops</code> database)</li>\n<li><code>Microservice</code> is able to initiate a direct REST-based communication to <code>Drops</code> and requests the <code>Access Token</code> without\nredirect</li>\n<li><code>Drops</code> responses with the users data</li>\n<li><code>Microservice</code> can initiate its own user session</li>\n</ol>\n<h2 id=\"web-apps\">Web Apps</h2>\n<p>Some microservices will implement a Web-App architecture. Such applications are based on HTML, CSS and Javascript. Mostly,\nthere is also some backend implementing a RESTful API to save and synchronize data entered by users.</p>\n<p>If the microservice credentials are saved on client devices, our concept of trusted OAuth2 handshake has serious security\nissues since we are not able to prevent misuse of these credentials. Thus, the backend systems have to handle the trusted \nOAuth2 handshake. </p>\n<p>The question remains of how to implement the user session for the frontend. Short answer: You won&#39;t need \na frontend session. The user session is needed for three purposes: (1) Control access, (2) use the user information \nfor further handling, and (3) display the user.</p>\n<p>First, you have to keep in mind, that your and your users data is protected by the backend. So, if a user tries to request\nspecific data using your RESTful API, your backend can grant or forbid access. Thus, if a user is entering spaces that \nare not allowed for this user, your backend won&#39;t send data, but it can send a status <code>403 FORBIDDEN</code> and an optional \nmessage. That way your frontend can handle the access control.</p>\n<p>Second, to handle the currently logged in user, your backend has to implement a special route that (1) is secured and (2)\nreturn the <code>UUID</code> of the user. Thus, the frontend can use the user in forms and other interaction elements. If your system\nhas to display the user (case (3)), you should use <a href=\"concepts/ui/fragment/composition\">widgets</a> for user display prepared \nby <em>Drops</em>.</p>\n<p>In case your frontend is delivered by a special webserver with no connection to your backend system, you have to implement\nthe trusted OAuth2 handshake for the delivering webserver to receive the users <code>UUID</code>.</p>\n<h2 id=\"oauth-message-broker\">OAuth Message broker</h2>\n<p>If the trusted OAuth2 handshake was successful, a users session can be established. An important requirement is to keep\nthe session synchronized. That means, updates of the exchanged user information have to be cascaded, and also the logout\nevent.</p>\n<p>For this purpose, the Pool² infrastructure hosts a message broker system. <em>Drops</em> publishes these events:</p>\n<pre><code>type: LOGOUT\nbody: UUID of user\n</code></pre><pre><code>type: user.UPDATE\nbody: UUID of user\n</code></pre><pre><code>type: user.CREATE\nbody: UUID of user\n</code></pre><pre><code>type: user.DELETE\nbody: UUID of user\n</code></pre><p>Your microservice can listen to these events for the purpose of synchronization. For further information about the message\nbroker see the <a href=\"guide/deployment\">guide for deployment</a>.</p>\n<p><strong>Author:</strong> <a href=\"https://cses.informatik.hu-berlin.de/members/johann.sell/\">Johann Sell</a> -- \n<strong>Created:</strong> 2018-06-05 --\n<strong>Updated:</strong> 2018-06-05</p>\n"},{"title":"UI Fragment Composition","slug":"concepts/ui/fragment/composition","contents":"<h1 id=\"ui-fragment-composition\">UI Fragment Composition</h1>\n<h2 id=\"templates\">Templates</h2>\n<h2 id=\"widgets\">Widgets</h2>\n<p><strong>Author:</strong> <a href=\"https://cses.informatik.hu-berlin.de/members/johann.sell/\">Johann Sell</a> -- \n<strong>Created:</strong> 2018-06-05 --\n<strong>Updated:</strong> 2018-06-05</p>\n"}]}}
