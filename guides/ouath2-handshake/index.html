<!DOCTYPE html><html lang="en-US"><head><title data-react-helmet="true"></title><link rel="preload" as="script" href="/bootstrap.a38652b5.js"/><link rel="preload" as="script" href="/templates/src/containers/Guide.719fb2c5.js"/><link rel="preload" as="script" href="/main.19a0e1f8.js"/><link rel="preload" as="style" href="/styles.5a2cde21.css"/><link rel="stylesheet" href="/styles.5a2cde21.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, shrink-to-fit=no"/></head><body><div id="root"><div data-reactroot=""><nav><a class="brand active" aria-current="true" href="/"><img src="data:image/png;base64,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" alt="Viva con Agua logo"/><div><span class="bold">Pool²</span><span>Documentation</span></div></a><a class="text" aria-current="false" href="/concepts">Concepts</a><a class="text active" aria-current="true" href="/guides">Guides</a><a class="text" aria-current="false" href="/rest">REST Interfaces</a><a class="text" aria-current="false" href="/about">About</a><span>This documentation is still under construction...</span></nav><div class="content"><div><a class="active" aria-current="true" href="/guides/">&lt;<!-- --> Back</a><br/><h3>OAuth2 handshake</h3><h1 id="oauth2-handshake">OAuth2 handshake</h1>
<p>Setting up the OAuth2 handshake requires two steps: (1) You have to register your microservice as an OAuth2 client in 
<em>Drops</em>. To do so, you have to contact the administrator of the Pool² and please her / him to add your microservice to 
the <em>Drops</em> database. If you setup a development system, you are the administrator by yourself. In that case consider 
the description below. (2) You have to implement your part of the handshake.</p>
<h2 id="setup-a-microservice-as-oauth2-client-in-drops">Setup a microservice as OAuth2 client in <em>Drops</em></h2>
<p>First, you have to log into <em>Drops</em> as an administrator. See <a href="/guides/setup-admin/">Setup administrator</a> to configure 
your user as an administrator. 
Second, create the microservice as a OAuth2 client: Open the appropriate form using the menu and enter an <strong>ID</strong>, a 
<strong>Secret</strong>, a <strong>Redirect URL</strong>, and a <strong>Grant type</strong> for the new service. </p>
<p>The <strong>ID</strong> can be any unique identifier, for example the microservices name. The <strong>Secret</strong> should be known only to 
<em>Drops</em> and the new microservice. Thus, I would recommend to generate a key using <a href="https://keepass.info/">KeePass</a> enter 
it into the form, save it in a KeePass database, and enter it to the microservices deployment configuration. The <strong>Redirect
URL</strong> will be defined by the microservice developer and should be given the Pool² admin. The given URL identifies the 
endpoint that is used by <em>Drops</em> to redirect the users client back, if the authorization code has been successfully 
created. The chosen <strong>Grant types</strong> define the possible authorization workflows possible between <em>Drops</em> and the 
microservice. Currently, <em>Drops</em> allows only <code>authorization code</code>.</p>
<h2 id="protocol-flow">Protocol flow</h2>
<p>The <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> defines multiple possible interactions between clients and OAuth 
provider. A general workflow is defined in §1.2 of the protocol. </p>
<p><em>Drops</em> implements the <code>authorization code</code> handshake. Thus, the client has to redirect to <em>Drops</em>, which redirects the
user to the login page, if no session exists. Otherwise, <em>Drops</em> will validate the requesting microservice, generates an
<code>authorization code</code>, and redirects back to the requesting microservice with the <code>authorization code</code> attached. Using 
this code, the service is able to request an <code>access token</code> that can be used to query information about <em>Drops</em> currently 
logged in user. At this point, the microservice is able to create its own user session. Handling of this additional user
session should be synchronized with the <em>Drops</em> session, thus we implemented a so called <em>OAuth message broker</em>.</p>
<p><img src="/oauth2-handshake.png" alt="OAuth2 handshake sequence diagram" title="Figure 1: Describes the calls and redirects between the users
client, the microservice and _Drops_. Please consider that there are no special cases, e.g. if the user has not already 
logged into _Drops_ or error cases."/></p>
<h2 id="endpoints">Endpoints</h2>
<p>Implementation of the OAuth2 handshake requires to know the endpoints of <em>Drops</em>, but also to know which enpoints have to
be implemented.</p>
<p>The following endpoints of <em>Drops</em> can be used:</p>
<pre><code>drops.authorization.code    =   ${drops.url.base}/oauth2/code/get/${ID}
drops.access.token          =   ${drops.url.base}/oauth2/access_token
drops.get.profile           =   ${drops.url.base}/oauth2/rest/profile?access_token=%sa
</code></pre><p>You have to replace the <code>${drops.url.base}</code> by the host and potentially path to the deployed <em>Drops</em> microservice.</p>
<p>There are some parameter to consider. First, to get an <code>authorization_code</code> <em>Drops</em> needs to identify your service. For 
this purpose, add the <strong>ID</strong> of your microservice as a path parameter: <code>${drops.url.base}/oauth2/code/get/${ID}</code>. </p>
<p>The access token endpoint expects some query parameter: <code>grant_type</code>, <code>client_id</code>, <code>client_secret</code>, <code>redirect_uri</code>, and 
<code>code</code>. While the <code>grant_type</code> has to be the currently chosen one (e.g. <code>authorization_code</code>), the next three parameter 
identify the microservice and have to be the same as added to <em>Drops</em>. The <code>code</code> parameter has to contain the received 
<code>authorization code</code>.</p>
<p>Last, requesting the profile information requires to hold a valid <code>access token</code> that has to be attached to the request 
as a query parameter.</p>
<p>Additionally, you have to prepare an endpoint by yourself, that takes an <code>authorization_code</code> and initiate the next step
using the <code>authorization_code</code>. <em>Drops</em> appends the <code>authorization_code</code> to the given <strong>Redirect URL</strong>, thus you are free
to design your URLs. Example endpoints: <code>https://ms.de/</code> (takes the code as part of the path), or <code>https://ms.de?code=</code> 
(expects the code as a query parameter with the name <code>code</code>). </p>
<h2 id="example">Example</h2>
<p>An example controller implemented using <a href="https://www.playframework.com/">Play2 Framework</a> and written in 
<a href="https://www.scala-lang.org/">Scala</a> could have the following functions:</p>
<pre><code class="lang-scala">package controllers

import javax.inject._

import models.AccessToken
import play.api._
import play.api.libs.json.Json
import play.api.mvc._
import play.api.libs.ws._
import play.api.Configuration

import scala.concurrent.ExecutionContext
import scala.concurrent.ExecutionContext.Implicits.global


class HomeController @Inject() (ws: WSClient,conf : Configuration) extends Controller {

  /**
   * Create an Action to render an HTML page with a welcome message.
   * The configuration in the `routes` file means that this method
   * will be called when the application receives a `GET` request with
   * a path of `/`.
   */
  def index = Action {
    Ok(views.html.index(&quot;Your new application is ready.&quot;))
  }

  def login = Action {
    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.code&quot;).get +
      conf.getString(&quot;drops.client_id&quot;).get
    Redirect(url)
  }

  def receiveCode(code: String) = Action.async {
    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.accessToken&quot;).get
    val clientId = conf.getString(&quot;drops.client_id&quot;).get
    val clientSecret = conf.getString(&quot;drops.client_secret&quot;).get

    val accessToken = ws.url(url).withQueryString(
      &quot;grant_type&quot; -&gt; &quot;authorization_code&quot;,
      &quot;client_id&quot; -&gt; clientId,
      &quot;client_secret&quot; -&gt; clientSecret,
      &quot;code&quot; -&gt; code,
      &quot;redirect_uri&quot; -&gt; &quot;http://localhost:8080/endpoint?code=&quot;
    ).get().map(response =&gt; response.status match {
      case 200 =&gt; AccessToken(response.json)
      case _ =&gt; println(response.status);throw new Exception 
                // Todo: throw meaningful exception considering the returned error message and status code!
    })

    accessToken.flatMap(token =&gt; {
      val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.profile&quot;).get

      ws.url(url).withQueryString(
        &quot;access_token&quot; -&gt; token.content
      ).get().map(response =&gt; response.status match {
        case 200 =&gt; Ok(
          Json.obj(&quot;status&quot; -&gt; &quot;success&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;user&quot; -&gt; response.json)
        )
        case _ =&gt; Ok(
          Json.obj(&quot;status&quot; -&gt; &quot;error&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;response-status&quot; -&gt; response.status)
        )
      })
    })
  }
}
</code></pre>
<p><strong>Author:</strong> <a href="https://cses.informatik.hu-berlin.de/members/johann.sell/">Johann Sell</a> -- 
<strong>Created:</strong> 2018-06-29 --
<strong>Updated:</strong> 2018-06-29</p></div></div></div></div><script type="text/javascript">window.__CSS_CHUNKS__ = {"main":"/styles.5a2cde21.css"}</script><script type="text/javascript">
                window.__routeInfo = {'path':'guides/ouath2-handshake','templateID':5,'sharedPropsHashes':{},'localProps':null,'allProps':{'guide':{'title':'OAuth2 handshake','slug':'ouath2-handshake','contents':'<h1 id="oauth2-handshake">OAuth2 handshake</h1>\n<p>Setting up the OAuth2 handshake requires two steps: (1) You have to register your microservice as an OAuth2 client in \n<em>Drops</em>. To do so, you have to contact the administrator of the Pool\xB2 and please her / him to add your microservice to \nthe <em>Drops</em> database. If you setup a development system, you are the administrator by yourself. In that case consider \nthe description below. (2) You have to implement your part of the handshake.</p>\n<h2 id="setup-a-microservice-as-oauth2-client-in-drops">Setup a microservice as OAuth2 client in <em>Drops</em></h2>\n<p>First, you have to log into <em>Drops</em> as an administrator. See <a href="/guides/setup-admin/">Setup administrator</a> to configure \nyour user as an administrator. \nSecond, create the microservice as a OAuth2 client: Open the appropriate form using the menu and enter an <strong>ID</strong>, a \n<strong>Secret</strong>, a <strong>Redirect URL</strong>, and a <strong>Grant type</strong> for the new service. </p>\n<p>The <strong>ID</strong> can be any unique identifier, for example the microservices name. The <strong>Secret</strong> should be known only to \n<em>Drops</em> and the new microservice. Thus, I would recommend to generate a key using <a href="https://keepass.info/">KeePass</a> enter \nit into the form, save it in a KeePass database, and enter it to the microservices deployment configuration. The <strong>Redirect\nURL</strong> will be defined by the microservice developer and should be given the Pool\xB2 admin. The given URL identifies the \nendpoint that is used by <em>Drops</em> to redirect the users client back, if the authorization code has been successfully \ncreated. The chosen <strong>Grant types</strong> define the possible authorization workflows possible between <em>Drops</em> and the \nmicroservice. Currently, <em>Drops</em> allows only <code>authorization code</code>.</p>\n<h2 id="protocol-flow">Protocol flow</h2>\n<p>The <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> defines multiple possible interactions between clients and OAuth \nprovider. A general workflow is defined in \xA71.2 of the protocol. </p>\n<p><em>Drops</em> implements the <code>authorization code</code> handshake. Thus, the client has to redirect to <em>Drops</em>, which redirects the\nuser to the login page, if no session exists. Otherwise, <em>Drops</em> will validate the requesting microservice, generates an\n<code>authorization code</code>, and redirects back to the requesting microservice with the <code>authorization code</code> attached. Using \nthis code, the service is able to request an <code>access token</code> that can be used to query information about <em>Drops</em> currently \nlogged in user. At this point, the microservice is able to create its own user session. Handling of this additional user\nsession should be synchronized with the <em>Drops</em> session, thus we implemented a so called <em>OAuth message broker</em>.</p>\n<p><img src="/oauth2-handshake.png" alt="OAuth2 handshake sequence diagram" title="Figure 1: Describes the calls and redirects between the users\nclient, the microservice and _Drops_. Please consider that there are no special cases, e.g. if the user has not already \nlogged into _Drops_ or error cases."></p>\n<h2 id="endpoints">Endpoints</h2>\n<p>Implementation of the OAuth2 handshake requires to know the endpoints of <em>Drops</em>, but also to know which enpoints have to\nbe implemented.</p>\n<p>The following endpoints of <em>Drops</em> can be used:</p>\n<pre><code>drops.authorization.code    =   ${drops.url.base}/oauth2/code/get/${ID}\ndrops.access.token          =   ${drops.url.base}/oauth2/access_token\ndrops.get.profile           =   ${drops.url.base}/oauth2/rest/profile?access_token=%sa\n</code></pre><p>You have to replace the <code>${drops.url.base}</code> by the host and potentially path to the deployed <em>Drops</em> microservice.</p>\n<p>There are some parameter to consider. First, to get an <code>authorization_code</code> <em>Drops</em> needs to identify your service. For \nthis purpose, add the <strong>ID</strong> of your microservice as a path parameter: <code>${drops.url.base}/oauth2/code/get/${ID}</code>. </p>\n<p>The access token endpoint expects some query parameter: <code>grant_type</code>, <code>client_id</code>, <code>client_secret</code>, <code>redirect_uri</code>, and \n<code>code</code>. While the <code>grant_type</code> has to be the currently chosen one (e.g. <code>authorization_code</code>), the next three parameter \nidentify the microservice and have to be the same as added to <em>Drops</em>. The <code>code</code> parameter has to contain the received \n<code>authorization code</code>.</p>\n<p>Last, requesting the profile information requires to hold a valid <code>access token</code> that has to be attached to the request \nas a query parameter.</p>\n<p>Additionally, you have to prepare an endpoint by yourself, that takes an <code>authorization_code</code> and initiate the next step\nusing the <code>authorization_code</code>. <em>Drops</em> appends the <code>authorization_code</code> to the given <strong>Redirect URL</strong>, thus you are free\nto design your URLs. Example endpoints: <code>https://ms.de/</code> (takes the code as part of the path), or <code>https://ms.de?code=</code> \n(expects the code as a query parameter with the name <code>code</code>). </p>\n<h2 id="example">Example</h2>\n<p>An example controller implemented using <a href="https://www.playframework.com/">Play2 Framework</a> and written in \n<a href="https://www.scala-lang.org/">Scala</a> could have the following functions:</p>\n<pre><code class="lang-scala">package controllers\n\nimport javax.inject._\n\nimport models.AccessToken\nimport play.api._\nimport play.api.libs.json.Json\nimport play.api.mvc._\nimport play.api.libs.ws._\nimport play.api.Configuration\n\nimport scala.concurrent.ExecutionContext\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n\nclass HomeController @Inject() (ws: WSClient,conf : Configuration) extends Controller {\n\n  /**\n   * Create an Action to render an HTML page with a welcome message.\n   * The configuration in the `routes` file means that this method\n   * will be called when the application receives a `GET` request with\n   * a path of `/`.\n   */\n  def index = Action {\n    Ok(views.html.index(&quot;Your new application is ready.&quot;))\n  }\n\n  def login = Action {\n    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.code&quot;).get +\n      conf.getString(&quot;drops.client_id&quot;).get\n    Redirect(url)\n  }\n\n  def receiveCode(code: String) = Action.async {\n    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.accessToken&quot;).get\n    val clientId = conf.getString(&quot;drops.client_id&quot;).get\n    val clientSecret = conf.getString(&quot;drops.client_secret&quot;).get\n\n    val accessToken = ws.url(url).withQueryString(\n      &quot;grant_type&quot; -&gt; &quot;authorization_code&quot;,\n      &quot;client_id&quot; -&gt; clientId,\n      &quot;client_secret&quot; -&gt; clientSecret,\n      &quot;code&quot; -&gt; code,\n      &quot;redirect_uri&quot; -&gt; &quot;http://localhost:8080/endpoint?code=&quot;\n    ).get().map(response =&gt; response.status match {\n      case 200 =&gt; AccessToken(response.json)\n      case _ =&gt; println(response.status);throw new Exception \n                // Todo: throw meaningful exception considering the returned error message and status code!\n    })\n\n    accessToken.flatMap(token =&gt; {\n      val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.profile&quot;).get\n\n      ws.url(url).withQueryString(\n        &quot;access_token&quot; -&gt; token.content\n      ).get().map(response =&gt; response.status match {\n        case 200 =&gt; Ok(\n          Json.obj(&quot;status&quot; -&gt; &quot;success&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;user&quot; -&gt; response.json)\n        )\n        case _ =&gt; Ok(\n          Json.obj(&quot;status&quot; -&gt; &quot;error&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;response-status&quot; -&gt; response.status)\n        )\n      })\n    })\n  }\n}\n</code></pre>\n<p><strong>Author:</strong> <a href="https://cses.informatik.hu-berlin.de/members/johann.sell/">Johann Sell</a> -- \n<strong>Created:</strong> 2018-06-29 --\n<strong>Updated:</strong> 2018-06-29</p>\n'}},'siteData':{'title':'Pool\xB2 Documentation'}};</script><script defer="" type="text/javascript" src="/bootstrap.a38652b5.js"></script><script defer="" type="text/javascript" src="/templates/src/containers/Guide.719fb2c5.js"></script><script defer="" type="text/javascript" src="/main.19a0e1f8.js"></script></body></html>