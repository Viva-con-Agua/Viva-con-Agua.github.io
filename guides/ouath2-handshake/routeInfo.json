{"path":"guides/ouath2-handshake","templateID":5,"sharedPropsHashes":{},"localProps":{"guide":{"title":"OAuth2 handshake","slug":"ouath2-handshake","contents":"<h1 id=\"oauth2-handshake\">OAuth2 handshake</h1>\n<p>Setting up the OAuth2 handshake requires two steps: (1) You have to register your microservice as an OAuth2 client in \n<em>Drops</em>. To do so, you have to contact the administrator of the Pool² and please her / him to add your microservice to \nthe <em>Drops</em> database. If you setup a development system, you are the administrator by yourself. In that case consider \nthe description below. (2) You have to implement your part of the handshake.</p>\n<h2 id=\"setup-a-microservice-as-oauth2-client-in-drops\">Setup a microservice as OAuth2 client in <em>Drops</em></h2>\n<p>First, you have to log into <em>Drops</em> as an administrator. See <a href=\"/guides/setup-admin/\">Setup administrator</a> to configure \nyour user as an administrator. \nSecond, create the microservice as a OAuth2 client: Open the appropriate form using the menu and enter an <strong>ID</strong>, a \n<strong>Secret</strong>, a <strong>Redirect URL</strong>, and a <strong>Grant type</strong> for the new service. </p>\n<p>The <strong>ID</strong> can be any unique identifier, for example the microservices name. The <strong>Secret</strong> should be known only to \n<em>Drops</em> and the new microservice. Thus, I would recommend to generate a key using <a href=\"https://keepass.info/\">KeePass</a> enter \nit into the form, save it in a KeePass database, and enter it to the microservices deployment configuration. The <strong>Redirect\nURL</strong> will be defined by the microservice developer and should be given the Pool² admin. The given URL identifies the \nendpoint that is used by <em>Drops</em> to redirect the users client back, if the authorization code has been successfully \ncreated. The chosen <strong>Grant types</strong> define the possible authorization workflows possible between <em>Drops</em> and the \nmicroservice. Currently, <em>Drops</em> allows only <code>authorization code</code>.</p>\n<h2 id=\"protocol-flow\">Protocol flow</h2>\n<p>The <a href=\"https://tools.ietf.org/html/rfc6749\">RFC 6749</a> defines multiple possible interactions between clients and OAuth \nprovider. A general workflow is defined in §1.2 of the protocol. </p>\n<p><em>Drops</em> implements the <code>authorization code</code> handshake. Thus, the client has to redirect to <em>Drops</em>, which redirects the\nuser to the login page, if no session exists. Otherwise, <em>Drops</em> will validate the requesting microservice, generates an\n<code>authorization code</code>, and redirects back to the requesting microservice with the <code>authorization code</code> attached. Using \nthis code, the service is able to request an <code>access token</code> that can be used to query information about <em>Drops</em> currently \nlogged in user. At this point, the microservice is able to create its own user session. Handling of this additional user\nsession should be synchronized with the <em>Drops</em> session, thus we implemented a so called <em>OAuth message broker</em>.</p>\n<p><img src=\"/oauth2-handshake.png\" alt=\"OAuth2 handshake sequence diagram\" title=\"Figure 1: Describes the calls and redirects between the users\nclient, the microservice and _Drops_. Please consider that there are no special cases, e.g. if the user has not already \nlogged into _Drops_ or error cases.\"></p>\n<h2 id=\"endpoints\">Endpoints</h2>\n<p>Implementation of the OAuth2 handshake requires to know the endpoints of <em>Drops</em>, but also to know which enpoints have to\nbe implemented.</p>\n<p>The following endpoints of <em>Drops</em> can be used:</p>\n<pre><code>drops.authorization.code    =   ${drops.url.base}/oauth2/code/get/${ID}\ndrops.access.token          =   ${drops.url.base}/oauth2/access_token\ndrops.get.profile           =   ${drops.url.base}/oauth2/rest/profile?access_token=%sa\n</code></pre><p>You have to replace the <code>${drops.url.base}</code> by the host and potentially path to the deployed <em>Drops</em> microservice.</p>\n<p>There are some parameter to consider. First, to get an <code>authorization_code</code> <em>Drops</em> needs to identify your service. For \nthis purpose, add the <strong>ID</strong> of your microservice as a path parameter: <code>${drops.url.base}/oauth2/code/get/${ID}</code>. </p>\n<p>The access token endpoint expects some query parameter: <code>grant_type</code>, <code>client_id</code>, <code>client_secret</code>, <code>redirect_uri</code>, and \n<code>code</code>. While the <code>grant_type</code> has to be the currently chosen one (e.g. <code>authorization_code</code>), the next three parameter \nidentify the microservice and have to be the same as added to <em>Drops</em>. The <code>code</code> parameter has to contain the received \n<code>authorization code</code>.</p>\n<p>Last, requesting the profile information requires to hold a valid <code>access token</code> that has to be attached to the request \nas a query parameter.</p>\n<p>Additionally, you have to prepare an endpoint by yourself, that takes an <code>authorization_code</code> and initiate the next step\nusing the <code>authorization_code</code>. <em>Drops</em> appends the <code>authorization_code</code> to the given <strong>Redirect URL</strong>, thus you are free\nto design your URLs. Example endpoints: <code>https://ms.de/</code> (takes the code as part of the path), or <code>https://ms.de?code=</code> \n(expects the code as a query parameter with the name <code>code</code>). </p>\n<h2 id=\"example\">Example</h2>\n<p>An example controller implemented using <a href=\"https://www.playframework.com/\">Play2 Framework</a> and written in \n<a href=\"https://www.scala-lang.org/\">Scala</a> could have the following functions:</p>\n<pre><code class=\"lang-scala\">package controllers\n\nimport javax.inject._\n\nimport models.AccessToken\nimport play.api._\nimport play.api.libs.json.Json\nimport play.api.mvc._\nimport play.api.libs.ws._\nimport play.api.Configuration\n\nimport scala.concurrent.ExecutionContext\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n\nclass HomeController @Inject() (ws: WSClient,conf : Configuration) extends Controller {\n\n  /**\n   * Create an Action to render an HTML page with a welcome message.\n   * The configuration in the `routes` file means that this method\n   * will be called when the application receives a `GET` request with\n   * a path of `/`.\n   */\n  def index = Action {\n    Ok(views.html.index(&quot;Your new application is ready.&quot;))\n  }\n\n  def login = Action {\n    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.code&quot;).get +\n      conf.getString(&quot;drops.client_id&quot;).get\n    Redirect(url)\n  }\n\n  def receiveCode(code: String) = Action.async {\n    val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.accessToken&quot;).get\n    val clientId = conf.getString(&quot;drops.client_id&quot;).get\n    val clientSecret = conf.getString(&quot;drops.client_secret&quot;).get\n\n    val accessToken = ws.url(url).withQueryString(\n      &quot;grant_type&quot; -&gt; &quot;authorization_code&quot;,\n      &quot;client_id&quot; -&gt; clientId,\n      &quot;client_secret&quot; -&gt; clientSecret,\n      &quot;code&quot; -&gt; code,\n      &quot;redirect_uri&quot; -&gt; &quot;http://localhost:8080/endpoint?code=&quot;\n    ).get().map(response =&gt; response.status match {\n      case 200 =&gt; AccessToken(response.json)\n      case _ =&gt; println(response.status);throw new Exception \n                // Todo: throw meaningful exception considering the returned error message and status code!\n    })\n\n    accessToken.flatMap(token =&gt; {\n      val url = conf.getString(&quot;drops.url.base&quot;).get + conf.getString(&quot;drops.url.profile&quot;).get\n\n      ws.url(url).withQueryString(\n        &quot;access_token&quot; -&gt; token.content\n      ).get().map(response =&gt; response.status match {\n        case 200 =&gt; Ok(\n          Json.obj(&quot;status&quot; -&gt; &quot;success&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;user&quot; -&gt; response.json)\n        )\n        case _ =&gt; Ok(\n          Json.obj(&quot;status&quot; -&gt; &quot;error&quot;, &quot;code&quot; -&gt; code, &quot;token&quot; -&gt; token.content, &quot;response-status&quot; -&gt; response.status)\n        )\n      })\n    })\n  }\n}\n</code></pre>\n<p><strong>Author:</strong> <a href=\"https://cses.informatik.hu-berlin.de/members/johann.sell/\">Johann Sell</a> -- \n<strong>Created:</strong> 2018-06-29 --\n<strong>Updated:</strong> 2018-06-29</p>\n"}}}
